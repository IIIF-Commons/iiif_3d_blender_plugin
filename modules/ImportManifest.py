
import json

from typing import Set, Callable, Iterable

import bpy
from bpy.props import StringProperty
from bpy.types import Collection, Context, Object, Operator
from bpy_extras.io_utils import ImportHelper

from .editing.collections import (  new_manifest,
                                    new_scene,
                                    new_annotation_page,
                                    new_annotation,
                                    move_collection_into_parent,
                                    move_object_into_collection,
                                    ANNOTATION_TYPE,
                                    ANNOTATIONPAGE_TYPE,
                                    SCENE_TYPE)
                                    
from .editing.transforms import Transform, Placement, transformsToPlacements
from .editing.models import walk_object_tree
from .editing.fileops import uri_scheme, uri_to_path

from .utils.color import hex_to_rgba
from .utils.json_patterns import (
    force_as_object,
    force_as_singleton
)


from .utils.blender_setup import set_scene_background_color

import logging

logger = logging.getLogger("Import")

# The ImportManifestError exception is intended for
# errors that result from errors in the manifest data
# or to flag unimplemented features

class ImportManifestError(Exception):
    pass
    
class ImportManifest(Operator, ImportHelper):
    """Import IIIF 3D Manifest"""

    bl_idname = "import_scene.iiif_manifest"
    bl_label = "Import IIIF 3D Manifest"

    filename_ext = ".json"
    filter_glob: StringProperty(  # type: ignore
        default="*.json", options={"HIDDEN"}
    )
    filepath: StringProperty(  # type: ignore
        name="File Path",
        description="Path to the input file",
        maxlen=1024,
        subtype="FILE_PATH",
    )

    manifest_data: dict

    def execute(self, context: Context) -> Set[str]:
        self.context : Context = context
        try:
            with open(self.filepath, "r", encoding="utf-8") as f:
                self.manifest_data = json.load(f)

            self.process_manifest(self.manifest_data)
            return {"FINISHED"}
        except Exception as e:
            raise
            self.report({"ERROR"}, f"Error reading manifest: {str(e)}")
            return {"CANCELLED"}

    def process_manifest(self, manifest_data: dict) -> None:
        """Process the manifest data and import the model"""

        # Store manifest metadata on the main scene collection
        main_collection = new_manifest( manifest_data )
        move_collection_into_parent( main_collection, self.context.scene.collection)

        if "items" in manifest_data:
            for item in manifest_data["items"][:]: # iterate over a copy
                if item.get("type",None) == SCENE_TYPE:
                    self.process_scene(item, main_collection)
                    manifest_data["items"].remove(item)

        main_collection["iiif_json"] = json.dumps(manifest_data)            

    def process_scene(self, scene_data: dict, manifest_collection : Collection) -> None:
        """Process annotation pages in a scene"""
        scene_collection = new_scene( scene_data)
        move_collection_into_parent(scene_collection, manifest_collection)
        
        bgColorHex = scene_data.get("backgroundColor", None)
        if bgColorHex:            
            bgColor=hex_to_rgba(bgColorHex)
            logger.info("setting background color to %r, %s" % (bgColor, bgColorHex))
            set_scene_background_color(bgColor)
            del scene_data["backgroundColor"]
        
        if "items" in scene_data:
            for item in scene_data.get("items", [])[:]:
                if item.get("type") == ANNOTATIONPAGE_TYPE:
                    self.process_annotation_page(item, scene_collection)
                    scene_data["items"].remove(item)
        scene_collection["iiif_json"] = json.dumps( scene_data )
        
    def process_annotation_page(
        self, annotation_page_data: dict, scene_collection: Collection
    ) -> None:
        page_collection = new_annotation_page( annotation_page_data )
        move_collection_into_parent(page_collection, scene_collection )
        # note in following loop the loop is over a copy
        # of the items list, generated by the [:] indexing
        for item in annotation_page_data.get("items", [])[:]:
            item_type = item.get("type","")
            if  item_type== ANNOTATION_TYPE:
                self.process_annotation(item, page_collection)
                annotation_page_data["items"].remove(item)
            else:
                message= f"unknown resource type {item_type} in AnnotationPage"
                logger.warn(message)
        page_collection["iiif_json"] = json.dumps(annotation_page_data)

    def process_annotation(
        self, annotation_data: dict, parent_collection: Collection
    ) -> None:
        
        target_data =  force_as_object(
            force_as_singleton(annotation_data.get("target", None)), default_type="Scene"
        )
        if target_data:
            del annotation_data["target"]
        
        body_data = force_as_object(
            force_as_singleton(annotation_data.get("body", None)), default_type="Model"
        )
        if body_data:
            del annotation_data["body"]
        else: 
            bodyValue = force_as_singleton(annotation_data.get("bodyValue", None))
            if type(bodyValue) is str:
                body_data = {"type": "TextualBody", "value": bodyValue}
                del annotation_data["bodyValue"]
            else:
                logger.warning(
                    "annotation %s has no body property" % annotation_data["id"]
                )
                
        anno_collection = new_annotation( annotation_data )
        move_collection_into_parent(anno_collection, parent_collection)
        
        
        
        anno_collection["iiif_json"] = json.dumps(annotation_data)
        
        
        new_object: Object = self.body_to_object(body_data, target_data )
        
        LOOP_GUARD_MAX=8
        for depth, _obj in walk_object_tree(new_object):
            if depth > LOOP_GUARD_MAX:
                raise Exception("infinite (or too deep) object parent-child tree")
            move_object_into_collection(_obj, anno_collection)
            
        return
                    
    def body_to_object(self, body_data : dict, target_data: dict) -> Object:
        """
        body is the  python dictionry obtained by unpacking hte json value of the body property.
        type of the outer layer of th dictionary may be SpecificResource, or may
        be Model, PerspectiveCamera
        
        The action of this function will be to create the Blender object, locate and
        orient the blender object; configure the Blender object via the properties in the
        body (or, as necesssary, SpecificResource.source). The created Blender object is returned
        
        returns a tuple of the dict obtained from the body or source, and the object itself
        These will contain information necessary to constr
        """     
        # placement_data is a dictionary whose entries will be filled with 
        # values from target and body, if either or both are SpecificResources   
        placement:Placement = self.get_object_placement(body_data, target_data)
        
        
        if body_data["type"] == "SpecificResource":
            resource_data = force_as_object(
             force_as_singleton(body_data.get("source", None)), default_type="Model"
            )
        else:
            resource_data = body_data
        
        resource_type :str = resource_data["type"]
        if resource_type == "Model":
            return self.resource_data_to_model(resource_data, placement)
        elif resource_type in ("PerspectiveCamera",):
            return self.resource_data_to_camera(resource_data, placement)
        raise ImportManifestError("Resource type %s not supported for annotation body" % resource_type)
# 
    def resource_data_to_model(self, resource_data : dict, placement : Placement) -> Object:
        """
        download, create, and configure model object
        """
        from .editing.models import configure_model
        
        try:
            model_url = resource_data["id"]
        except KeyError:
            raise ImportManifestError("no url for model provided")
        mimetype = resource_data.get("format","")
        
        scheme = uri_scheme(model_url)
        if scheme in {"http" , "https"}:
            _op_network : Callable[..., Set[str]] = bpy.ops.iiif.load_network_model # pyright:ignore[reportAttributeAccessIssue]
            import_result = _op_network(model_url=model_url, mimetype = mimetype ) 
            logger.debug("bpy.ops.iiif.load_network_model result: %r" % import_result)
            if "FINISHED" not in import_result:
                raise ImportManifestError("import Operation failed with %r" % import_result)

        elif scheme in {"file"}:
            _op_local : Callable[..., Set[str]] = bpy.ops.iiif.load_local_model # pyright:ignore[reportAttributeAccessIssue]
            model_filepath = uri_to_path(model_url)
            import_result = _op_local(filepath=model_filepath, mimetype = mimetype ) 
            logger.debug("bpy.ops.iiif.load_network_model result: %r" % import_result)
            if "FINISHED" not in import_result:
                raise ImportManifestError("import Operation failed with %r" % import_result)
        
        else:
            raise ImportManifestError("unsupported scheme %s for model url %s" % (scheme, model_url))
                        
        new_model = bpy.context.active_object
        if new_model is None:
            raise ImportManifestError("bpy.context.active_object not set")
        
        configure_model(new_model, resource_data,  placement)
        return new_model
         
    def resource_data_to_camera(self, resource_data, placement) -> Object:
        """
        create, and configure camera object
        """
        from .editing.cameras import configure_camera
        try:
            retCode = bpy.ops.object.camera_add()
            logger.info("obj.camera_add %r" % (retCode,))
        except Exception as exc:
            logger.error("add camera error", exc)

        new_camera = bpy.context.active_object
        if new_camera is None:
            raise  ImportManifestError("failed to add camera")
            
        configure_camera(   new_camera,
                            resource_data,
                            placement)
        return new_camera
        

    
    def get_object_placement(self, body_data:dict , target_data : dict) -> Placement:
        """
        examines the content of target_data dictionary and identify if
        properties of the target determine information on placement of model 
        in the Blender scene
        
        Will always return a not None value, if no Transforms are in the body_data
        or target_data, the return value will be the identity Placement
        
        The placement (combination of scale, rotation, and translation ) returned by
        this function only includes the action defined in the transform property of
        a SpecificResource instance in the body property or a PointSelector in the 
        target property. The placement returned by this function does not include any
        scale,rotation,translation defined during import of a model resource, or of
        the rotation required to transform a default Blender camera to a default IIIF
        camera. It will be the role of the configure_camera / configure_model functions
        to combine the geometric effects of all placements on a resource.
        """
        
        def iiif_transforms() -> Iterable[dict]:
            """
            generator yielding editing.Transform nodes
            """
            if  body_data.get("type","") == "SpecificResource":
                for iiif_transform in body_data.get("transform",""):
                    yield iiif_transform

            if  target_data.get("type","") == "SpecificResource":
                selector = force_as_singleton( target_data["selector"] )
                if selector and selector.get("type","") == "PointSelector":
                    yield selector
                    
        placements = list(
            transformsToPlacements(                               
                    map(Transform.from_iiif_dict, iiif_transforms())
            )
        )
        
        if len(placements) == 0:
            return Placement()
        elif len(placements) == 1:
            return placements[0]
        else:
            raise Exception()
        
        
            
        
