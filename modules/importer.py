import datetime
import json
import os
import urllib.request
from typing import Set

import bpy
from bpy.props import StringProperty
from bpy.types import Collection, Context, Object, Operator
from bpy_extras.io_utils import ImportHelper
from mathutils import Vector

from .metadata import IIIFMetadata
from .utils.color import hex_to_rgba
from .utils.coordinates import Coordinates
from .utils.json_patterns import (
    force_as_object,
    force_as_singleton,
    force_as_list,
    axes_named_values,
)
from .editing.initialize_collections import generate_uri

from .utils.blender_setup import configure_camera,set_scene_background_color

import math

import logging

logger = logging.getLogger("Import")

# The ImportManifestError exception is intended for
# errors that result from errors in the manifest data
# or to flag unimplemented features

class ImportManifestError(Exception):
    pass
    
class ImportIIIF3DManifest(Operator, ImportHelper):
    """Import IIIF 3D Manifest"""

    bl_idname = "import_scene.iiif_manifest"
    bl_label = "Import IIIF 3D Manifest"

    filename_ext = ".json"
    filter_glob: StringProperty(  # type: ignore
        default="*.json", options={"HIDDEN"}
    )
    filepath: StringProperty(  # type: ignore
        name="File Path",
        description="Path to the input file",
        maxlen=1024,
        subtype="FILE_PATH",
    )

    manifest_data: dict

    def execute(self, context: Context) -> Set[str]:
        try:
            with open(self.filepath, "r", encoding="utf-8") as f:
                self.manifest_data = json.load(f)

            self.report({"DEBUG"}, f"Successfully read manifest from {self.filepath}")
            self.report({"DEBUG"}, f"Manifest data: {self.manifest_data}")
            self.process_manifest(self.manifest_data)
            self.report(
                {"DEBUG"}, f"Successfully imported manifest from {self.filepath}"
            )

            return {"FINISHED"}
        except Exception as e:
            import traceback

            self.report({"ERROR"}, f"Error reading manifest: {str(e)}")
            traceback.print_exc()
            return {"CANCELLED"}

    def process_manifest(self, manifest_data: dict) -> None:
        """Process the manifest data and import the model"""

        # Store manifest metadata on the main scene collection
        main_collection = self.create_or_get_collection("IIIF Manifest")
        metadata = IIIFMetadata(main_collection)
        metadata.store_manifest(manifest_data)
        
        main_collection["iiif_id"] = manifest_data["id"]
        main_collection["iiif_type"] = "Manifest"

        if "items" in manifest_data:
            for item in manifest_data["items"][:]: # iterate over a copy
                if item.get("type",None) == "Scene":
                    self.process_scene(item, main_collection)
                    manifest_data["items"].remove(item)

        main_collection["iiif_json"] = json.dumps(manifest_data)            

    def process_scene(self, scene_data: dict, manifest_collection) -> None:
        """Process annotation pages in a scene"""
        scene_collection = self.create_or_get_collection(
            self.get_iiif_id_or_label(scene_data), manifest_collection
        )
        
        metadata = IIIFMetadata(scene_collection)
        metadata.store_scene(scene_data)

        bgColorHex = scene_data.get("backgroundColor", None)
        if bgColorHex:            
            bgColor=hex_to_rgba(bgColorHex)
            logger.info("setting background color to %r, %s" % (bgColor, bgColorHex))
            set_scene_background_color(bgColor)
            del scene_data["backgroundColor"]

        scene_collection["iiif_id"] = scene_data["id"]
        scene_collection["iiif_type"] = "Scene"
        
        if "items" in scene_data:
            for item in scene_data.get("items", [])[:]:
                if item.get("type") == "AnnotationPage":
                    self.process_annotation_page(item, scene_collection)
                    scene_data["items"].remove(item)
        scene_collection["iiif_json"] = json.dumps( scene_data )
        
    def process_annotation_page(
        self, annotation_page_data: dict, scene_collection: Collection
    ) -> None:
        page_collection = self.create_or_get_collection(
            self.get_iiif_id_or_label(annotation_page_data), scene_collection
        )
        
        page_collection["iiif_id"] = annotation_page_data.get("id")
        page_collection["iiif_type"] = "AnnotationPage"
        
        # note in following loop the loop is over a copy
        # of the items list, generated by the [:] indexing
        for item in annotation_page_data.get("items", [])[:]:
            if item.get("type") == "Annotation":
                self.process_annotation(item, page_collection)
                annotation_page_data["items"].remove(item)
            else:
                self.report({"WARNING"}, f"Unknown item type: {item.get('type')}")
        page_collection["iiif_json"] = json.dumps(annotation_page_data)

    def process_annotation(
        self, annotation_data: dict, parent_collection: Collection
    ) -> None:
        logger.debug("processing annotation %s" % annotation_data["id"])
        target_data =  force_as_object(
            force_as_singleton(annotation_data.get("target", None)), default_type="Scene"
        )
        if target_data:
            del annotation_data["target"]
        
        body_data = force_as_object(
            force_as_singleton(annotation_data.get("body", None)), default_type="Model"
        )
        if body_data:
            del annotation_data["body"]
        else: 
            bodyValue = force_as_singleton(annotation_data.get("bodyValue", None))
            if type(bodyValue) is str:
                body_data = {"type": "TextualBody", "value": bodyValue}
                del annotation_data["bodyValue"]
            else:
                logger.warning(
                    "annotation %s has no body property" % annotation_data["id"]
                )
                
        anno_collection = self.create_or_get_collection(annotation_data["id"], parent_collection)
        anno_collection["iiif_id"]   = annotation_data["id"]
        anno_collection["iiif_type"] = annotation_data["type"]
        anno_collection["iiif_json"] = json.dumps(annotation_data)
        
        # Developer note 13 Jun 2025
        # the body_to_object function returns a Blender object which ia the model
        # camera, or light; but at this revision  this object
        # is not needed at this stage of the import
        self.body_to_object(body_data, target_data, anno_collection )
        return
                    
    def download_model(self, url: str) -> str:
        """Download the model file from the given URL"""
        temp_dir = bpy.app.tempdir
        time_string = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        model_name = os.path.basename(url)
        model_extension = os.path.splitext(model_name)[1]
        temp_file = os.path.join(
            temp_dir, f"temp_model_{time_string}_{model_name}{model_extension}"
        )

        try:
            self.report({"DEBUG"}, f"Downloading model from {url} to {temp_file}")
            urllib.request.urlretrieve(url, temp_file)
            self.report({"DEBUG"}, f"Successfully downloaded model to {temp_file}")
            return temp_file
        except Exception as e:
            self.report({"ERROR"}, f"Error downloading model: {str(e)}")
            raise

    def import_model(self, filepath: str) -> None:
        """Import the model file using the appropriate Blender importer"""
        file_ext = os.path.splitext(filepath)[1].lower()

        if file_ext == ".glb" or file_ext == ".gltf":
            bpy.ops.import_scene.gltf(filepath=filepath)
        else:
            raise ValueError(f"Unsupported file format: {file_ext}")

    def create_or_get_collection(
        self, name: str, parent: Collection | None = None
    ) -> Collection:
        """Create a new collection or get existing one"""
        if name in bpy.data.collections:
            collection = bpy.data.collections[name]
        else:
            collection = bpy.data.collections.new(name)
            if parent:
                parent.children.link(collection)
            else:
                bpy.context.scene.collection.children.link(collection)

        return collection

    def get_iiif_id_or_label(self, data: dict) -> str:
        """Get the IIIF ID or label from the given data"""
        iiif_id = data.get("id", "Unnamed ID")
        label = data.get("label", {}).get("en", [iiif_id])[0]
        return label

    def body_to_object(self, body_data : dict, target_data: dict, anno_collection:Collection) -> Object:
        """
        body is the  python dictionry obtained by unpacking hte json value of the body property.
        type of the outer layer of th dictionary may be SpecificResource, or may
        be Model, PerspectiveCamera
        
        The action of this function will be to create the Blender object, locate and
        orient the blender object; configure the Blender object via the properties in the
        body (or, as necesssary, SpecificResource.source). The created Blender object is returned
        
        returns a tuple of the dict obtained from the body or source, and the object itself
        These will contain information necessary to constr
        """     
        # placement_data is a dictionary whose entries will be filled with 
        # values from target and body, if either or both are SpecificResources   
        placement_data = {
        "location" : None,
        "rotation" : None,
        "scale"    : None
        }
        
        self.update_placement_from_target(target_data, placement_data)
        if body_data["type"] == "SpecificResource":
            resource_data = force_as_object(
                force_as_singleton(body_data.get("source", None)), default_type="Model"
            )
            self.update_placement_from_body(body_data, placement_data)
        else:
            resource_data = body_data

        resource_type :str = resource_data["type"]
        if resource_type == "Model":
            return self.resource_data_to_model(resource_data, placement_data, anno_collection)
        elif resource_type in ("PerspectiveCamera",):
            return self.resource_data_to_camera(resource_data, placement_data, anno_collection)
        raise ImportManifestError("Resource type %s not supported for annotation body" % resource_type)

    def resource_data_to_model(self, resource_data, placement_data, anno_collection) -> Object:
        """
        download, create, and configure model object
        """
        model_id = resource_data.get("id", None)
        
        temp_file = self.download_model(model_id)
        self.import_model(temp_file)
        new_model = bpy.context.active_object
        if new_model is None:
            raise ImportManifestError("bpy.context.active_object not set")
        else:
            new_model["iiif_id"] = model_id
            new_model["iiif_type"] = "Model"
            new_model["iiif_json"] = json.dumps(resource_data)
            
            if placement_data["location"] is not None:
                new_model.location = Coordinates.iiif_position_to_blender_vector( placement_data["location"] )
                
            if placement_data["rotation"] is not None:
                saved_mode = new_model.rotation_mode
                try:
                    euler = Coordinates.model_transform_angles_to_blender_euler( placement_data["rotation"] )
                    new_model.rotation_mode = euler.order
                    new_model.rotation_euler = euler
                finally:
                    new_model.rotation_mode = saved_mode            
    
            if placement_data["scale"] is not None:
                new_model.scale = Vector( placement_data["scale"] )
            
            # ensure the model is in the anno_collection; this is
            # required for IIIF Manifest export
            for col in new_model.users_collection:
                col.objects.unlink(new_model)
            anno_collection.objects.link(new_model)
        return new_model
        
    def resource_data_to_camera(self, resource_data, placement_data, anno_collection) -> Object:
        """
        create, and configure camera object
        """

        try:
            retCode = bpy.ops.object.camera_add()
            logger.info("obj.camera_add %r" % (retCode,))
        except Exception as exc:
            logger.error("add camera error", exc)

        new_camera = bpy.context.active_object
        if new_camera is not None:
            configure_camera( new_camera )
            
            if "fieldOfView" in resource_data:
                foV = force_as_singleton(resource_data["fieldOfView"])
                if foV is not None: 
                    new_camera.data.angle_y = math.radians( float( foV )) # pyright: ignore[reportAttributeAccessIssue, reportOptionalMemberAccess]
                    del resource_data["fieldOfView"]
                
            new_camera["iiif_id"] = generate_uri("PerspectiveCamera")
            new_camera["iiif_type"] = "PerspectiveCamera"
            new_camera["iiif_json"] = json.dumps(resource_data)
            
            if placement_data["location"] is not None:
                new_camera.location = Coordinates.iiif_position_to_blender_vector( placement_data["location"] )
                
            if placement_data["rotation"] is not None:
                euler = Coordinates.camera_transform_angles_to_blender_euler( placement_data["rotation"] )
                new_camera.rotation_mode = euler.order
                new_camera.rotation_euler = euler
    
                
            # ensure the model is in the anno_collection; this is
            # required for IIIF Manifest export
            for col in new_camera.users_collection:
                col.objects.unlink(new_camera)
            anno_collection.objects.link(new_camera)
            return new_camera
        else:
            raise ImportManifestError("unable to import camera")

    
    def update_placement_from_target(self, target_data, placement_data):
        """
        examines the content of target_data dictionary and identify if
        properties of the target determine information on placement of model 
        in the Blender scene
        
        At this implementation the case of the target_data representing a SpecificResource
        with a PointSelector will be handled.
        
        value of the location property will be set with a 3-tuple in IIIIF Coordinates       
        """
        if  target_data["type"] == "SpecificResource":
            sel = force_as_singleton( target_data["selector"] )
            if sel and sel["type"] == "PointSelector":
                placement_data["location"] = axes_named_values( sel )
        return
        
    def update_placement_from_body(self, body_data, placement_data):
        """
        examines the content of body_data dictionary and identify if
        properties of the body determine information on placement of model 
        in the Blender scene
        
        At this implementation the case of the target_data representing a SpecificResource
        with a transform property
        
        value of the rotation and scale property will be set with a 3-tuple in IIIIF Coordinates 
        """
        if  body_data["type"] == "SpecificResource" and \
            body_data.get("transform", False):
            for transform in force_as_list(body_data["transform"]):
                for transform_compare, placement_property in (
                    ("RotateTransform","rotation"),
                    ("ScaleTransform","scale"),
                ):
                    transform_type = transform["type"]
                    if transform_type == transform_compare:
                        if placement_data[placement_property] is not None:
                            logger.warning("%s is being overwritten" % placement_property)
                        placement_data[placement_property] = axes_named_values(transform)
        return
           
    

    


                
    
