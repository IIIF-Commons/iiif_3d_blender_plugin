
import json

from typing import Set, Callable

import bpy
from bpy.props import StringProperty
from bpy.types import Collection, Context, Object, Operator
from bpy_extras.io_utils import ImportHelper

from .editing.collections import (  new_manifest,
                                    new_scene,
                                    new_annotation_page,
                                    new_annotation,
                                    ANNOTATION_TYPE,
                                    ANNOTATIONPAGE_TYPE,
                                    SCENE_TYPE)

from .utils.color import hex_to_rgba
from .utils.json_patterns import (
    force_as_object,
    force_as_singleton,
    force_as_list,
    axes_named_values,
)


from .utils.blender_setup import set_scene_background_color

import logging

logger = logging.getLogger("Import")

# The ImportManifestError exception is intended for
# errors that result from errors in the manifest data
# or to flag unimplemented features

class ImportManifestError(Exception):
    pass
    
class ImportIIIF3DManifest(Operator, ImportHelper):
    """Import IIIF 3D Manifest"""

    bl_idname = "import_scene.iiif_manifest"
    bl_label = "Import IIIF 3D Manifest"

    filename_ext = ".json"
    filter_glob: StringProperty(  # type: ignore
        default="*.json", options={"HIDDEN"}
    )
    filepath: StringProperty(  # type: ignore
        name="File Path",
        description="Path to the input file",
        maxlen=1024,
        subtype="FILE_PATH",
    )

    manifest_data: dict

    def execute(self, context: Context) -> Set[str]:
        try:
            with open(self.filepath, "r", encoding="utf-8") as f:
                self.manifest_data = json.load(f)

            self.process_manifest(self.manifest_data)
            return {"FINISHED"}
        except Exception as e:
            self.report({"ERROR"}, f"Error reading manifest: {str(e)}")
            return {"CANCELLED"}

    def process_manifest(self, manifest_data: dict) -> None:
        """Process the manifest data and import the model"""

        # Store manifest metadata on the main scene collection
        main_collection = new_manifest( manifest_data )
        bpy.context.scene.collection.children.link(main_collection)

        if "items" in manifest_data:
            for item in manifest_data["items"][:]: # iterate over a copy
                if item.get("type",None) == SCENE_TYPE:
                    self.process_scene(item, main_collection)
                    manifest_data["items"].remove(item)

        main_collection["iiif_json"] = json.dumps(manifest_data)            

    def process_scene(self, scene_data: dict, manifest_collection : Collection) -> None:
        """Process annotation pages in a scene"""
        scene_collection = new_scene( scene_data)

        bgColorHex = scene_data.get("backgroundColor", None)
        if bgColorHex:            
            bgColor=hex_to_rgba(bgColorHex)
            logger.info("setting background color to %r, %s" % (bgColor, bgColorHex))
            set_scene_background_color(bgColor)
            del scene_data["backgroundColor"]
        
        if "items" in scene_data:
            for item in scene_data.get("items", [])[:]:
                if item.get("type") == ANNOTATIONPAGE_TYPE:
                    self.process_annotation_page(item, scene_collection)
                    scene_data["items"].remove(item)
        scene_collection["iiif_json"] = json.dumps( scene_data )
        
    def process_annotation_page(
        self, annotation_page_data: dict, scene_collection: Collection
    ) -> None:
        page_collection = new_annotation_page( annotation_page_data )
                
        # note in following loop the loop is over a copy
        # of the items list, generated by the [:] indexing
        for item in annotation_page_data.get("items", [])[:]:
            if item.get("type") == ANNOTATION_TYPE:
                self.process_annotation(item, page_collection)
                annotation_page_data["items"].remove(item)
            else:
                self.report({"WARNING"}, f"Unknown item type: {item.get('type')}")
        page_collection["iiif_json"] = json.dumps(annotation_page_data)

    def process_annotation(
        self, annotation_data: dict, parent_collection: Collection
    ) -> None:

        target_data =  force_as_object(
            force_as_singleton(annotation_data.get("target", None)), default_type="Scene"
        )
        if target_data:
            del annotation_data["target"]
        
        body_data = force_as_object(
            force_as_singleton(annotation_data.get("body", None)), default_type="Model"
        )
        if body_data:
            del annotation_data["body"]
        else: 
            bodyValue = force_as_singleton(annotation_data.get("bodyValue", None))
            if type(bodyValue) is str:
                body_data = {"type": "TextualBody", "value": bodyValue}
                del annotation_data["bodyValue"]
            else:
                logger.warning(
                    "annotation %s has no body property" % annotation_data["id"]
                )
                
        anno_collection = new_annotation( annotation_data )
        parent_collection.children.link(anno_collection)
        
        
        anno_collection["iiif_json"] = json.dumps(annotation_data)
        
        # Developer note 13 Jun 2025
        # the body_to_object function returns a Blender object which ia the model
        # camera, or light; but at this revision  this object
        # is not needed at this stage of the import
        self.body_to_object(body_data, target_data )
        return
                    
    def body_to_object(self, body_data : dict, target_data: dict) -> Object:
        """
        body is the  python dictionry obtained by unpacking hte json value of the body property.
        type of the outer layer of th dictionary may be SpecificResource, or may
        be Model, PerspectiveCamera
        
        The action of this function will be to create the Blender object, locate and
        orient the blender object; configure the Blender object via the properties in the
        body (or, as necesssary, SpecificResource.source). The created Blender object is returned
        
        returns a tuple of the dict obtained from the body or source, and the object itself
        These will contain information necessary to constr
        """     
        # placement_data is a dictionary whose entries will be filled with 
        # values from target and body, if either or both are SpecificResources   
        placement_data = self.get_object_placement(body_data, target_data)
        
        
        if body_data["type"] == "SpecificResource":
            resource_data = force_as_object(
             force_as_singleton(body_data.get("source", None)), default_type="Model"
            )
        else:
            resource_data = body_data
        
        resource_type :str = resource_data["type"]
        if resource_type == "Model":
            return self.resource_data_to_model(resource_data, placement_data)
        elif resource_type in ("PerspectiveCamera",):
            return self.resource_data_to_camera(resource_data, placement_data)
        raise ImportManifestError("Resource type %s not supported for annotation body" % resource_type)
# 
    def resource_data_to_model(self, resource_data, placement_data) -> Object:
        """
        download, create, and configure model object
        """
        from .editing.models import configure_model
        
        model_url = resource_data.get("id", None)
        if model_url is None:
            raise ImportManifestError("no url for model provided")
        mimetype = resource_data.get("format","")
        _op : Callable[..., Set[str]] = bpy.ops.iiif.import_network_model # pyright:ignore[reportAttributeAccessIssue]
        import_result = _op(model_url=model_url, mime_type = mimetype ) 
        logger.debug("bpy.ops.iiif.import_model result: %r" % import_result)
        if "FINISHED" not in import_result:
            raise ImportManifestError("import Operation failed with %r" % import_result)

        new_model = bpy.context.active_object
        if new_model is None:
            raise ImportManifestError("bpy.context.active_object not set")
        
        configure_model(new_model, resource_data,  placement_data)
        return new_model
         
    def resource_data_to_camera(self, resource_data, placement_data) -> Object:
        """
        create, and configure camera object
        """
        from .editing.cameras import configure_camera
        try:
            retCode = bpy.ops.object.camera_add()
            logger.info("obj.camera_add %r" % (retCode,))
        except Exception as exc:
            logger.error("add camera error", exc)

        new_camera = bpy.context.active_object
        if new_camera is None:
            raise  ImportManifestError("failed to add camera")
            
        configure_camera(   new_camera,
                            resource_data = resource_data, 
                            placement_data =  placement_data)
        return new_camera
        

    
    def get_object_placement(self, body_data:dict , target_data : dict):
        """
        examines the content of target_data dictionary and identify if
        properties of the target determine information on placement of model 
        in the Blender scene
        
        At this implementation the case of the target_data representing a SpecificResource
        with a PointSelector will be handled.
        
        value of the location property will be set with a 3-tuple in IIIIF Coordinates       
        
        examines the content of body_data dictionary and identify if
        properties of the body determine information on placement of model 
        in the Blender scene
        
        At this implementation the case of the target_data representing a SpecificResource
        with a transform property
        
        value of the rotation and scale property will be set with a 3-tuple in IIIIF Coordinates 
        """
        
        placement_data = {}
        
        if  body_data["type"] == "SpecificResource" and \
            body_data.get("transform", False):
            for transform in force_as_list(body_data["transform"]):
                for transform_compare, placement_property in (
                    ("RotateTransform","rotation"),
                    ("ScaleTransform","scale"),
                ):
                    transform_type = transform["type"]
                    if transform_type == transform_compare:
                        if placement_data[placement_property] is not None:
                            logger.warning("%s is being overwritten" % placement_property)
                        placement_data[placement_property] = axes_named_values(transform)

        if  target_data["type"] == "SpecificResource":
            sel = force_as_singleton( target_data["selector"] )
            if sel and sel["type"] == "PointSelector":
                placement_data["location"] = axes_named_values( sel )
        return
        
